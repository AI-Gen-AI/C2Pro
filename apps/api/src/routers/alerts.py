# CE-S4-009: Alerts API Router
#
# This router exposes endpoints for managing and resolving alerts generated by
# the Coherence Engine.
#
# Performance Note:
# The `alerts` table is expected to grow large. For the queries in this router
# to be performant, it is crucial to have a composite index on:
# (project_id, status, severity, created_at DESC)
# This was implemented in migration 008_indexes.sql.

from typing import Generic, List, Optional, TypeVar
from pydantic import BaseModel, Field
from enum import Enum

T = TypeVar("T")

# --- Enums ---
class AlertStatus(str, Enum):
    OPEN = "OPEN"
    RESOLVED = "RESOLVED"
    DISMISSED = "DISMISSED"

class AlertSeverity(str, Enum):
    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"

class AlertCategory(str, Enum):
    COST = "COST"
    SCHEDULE = "SCHEDULE"
    SCOPE = "SCOPE"
    QUALITY = "QUALITY"

# --- Pydantic Models ---

class AlertBase(BaseModel):
    category: AlertCategory
    severity: AlertSeverity
    source_clause_id: str
    description: str
    evidence_json: dict
    affected_object_ids: List[str]

class AlertRead(AlertBase):
    id: int
    project_id: int
    status: AlertStatus

    class Config:
        orm_mode = True

class AlertUpdate(BaseModel):
    status: AlertStatus
    user_comment: Optional[str] = Field(
        None,
        description="Comment from the user when resolving or dismissing an alert."
    )

# --- Pagination stubs (avoid optional dependency during tests) ---
class Page(BaseModel, Generic[T]):
    items: List[T] = []
    total: int = 0
    page: int = 1
    size: int = 0

async def paginate(*, query, model, cursor, limit, order_by, order_direction) -> Page[T]:
    return Page(items=[], total=0, page=1, size=0)

# --- API Router ---
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
# from .. import schemas, models
# from ..core.db import get_db
# from ..core.pagination import Page, paginate

# This is a placeholder for the actual Alert model
class Alert:
    pass

# This is a placeholder for the get_db dependency
def get_db():
    pass

router = APIRouter(
    prefix="/alerts",
    tags=["alerts"],
    responses={404: {"description": "Not found"}},
)

@router.get("/projects/{project_id}/alerts", response_model=Page[AlertRead])
async def list_alerts_for_project(
    project_id: int,
    db: Session = Depends(get_db),
    severities: Optional[List[AlertSeverity]] = Query(None),
    status: Optional[List[AlertStatus]] = Query([AlertStatus.OPEN]),
    category: Optional[AlertCategory] = Query(None),
    cursor: Optional[str] = None,
    limit: int = 20,
):
    """
    List alerts for a specific project with filtering and pagination.
    """
    query = db.query(Alert).filter(Alert.project_id == project_id)

    if severities:
        query = query.filter(Alert.severity.in_(severities))
    if status:
        query = query.filter(Alert.status.in_(status))
    if category:
        query = query.filter(Alert.category == category)

    # Order by severity (Critical first) and then by creation date
    query = query.order_by(Alert.severity.desc(), Alert.created_at.desc())

    return await paginate(
        query=query,
        model=Alert,
        cursor=cursor,
        limit=limit,
        order_by="created_at",
        order_direction="desc"
    )

@router.patch("/alerts/{alert_id}", response_model=AlertRead)
async def update_alert(
    alert_id: int,
    alert_update: AlertUpdate,
    db: Session = Depends(get_db),
    # current_user: models.User = Depends(get_current_user), # Placeholder
):
    """
    Update an alert's status and add a user comment.
    """
    alert = db.query(Alert).filter(Alert.id == alert_id).first()
    if not alert:
        raise HTTPException(status_code=404, detail="Alert not found")

    # --- Security Check ---
    # Placeholder for checking if the user has write permissions on the project.
    # if not user_can_write_to_project(current_user, alert.project_id):
    #     raise HTTPException(status_code=403, detail="Not authorized to update this alert")

    if alert.status != AlertStatus.OPEN:
        raise HTTPException(
            status_code=400,
            detail=f"Cannot update an alert that is already {alert.status.value}"
        )
    
    if alert_update.status not in [AlertStatus.RESOLVED, AlertStatus.DISMISSED]:
        raise HTTPException(
            status_code=400,
            detail="Alert status can only be updated to RESOLVED or DISMISSED"
        )

    alert.status = alert_update.status
    if alert_update.user_comment:
        alert.user_comment = alert_update.user_comment

    db.commit()
    db.refresh(alert)
    return alert

@router.get("/alerts/{alert_id}", response_model=AlertRead)
async def get_alert(
    alert_id: int,
    db: Session = Depends(get_db),
    # current_user: models.User = Depends(get_current_user), # Placeholder
):
    """
    Get a single alert by its ID.
    """
    alert = db.query(Alert).filter(Alert.id == alert_id).first()
    if not alert:
        raise HTTPException(status_code=404, detail="Alert not found")

    # --- Security Check ---
    # Placeholder for checking if the user has read permissions on the project.
    # if not user_can_read_project(current_user, alert.project_id):
    #     raise HTTPException(status_code=403, detail="Not authorized to view this alert")

    return alert
