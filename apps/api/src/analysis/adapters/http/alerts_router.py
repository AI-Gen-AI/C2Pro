"""
C2Pro - Alerts API Router

This router exposes endpoints for managing and resolving alerts generated by
the Coherence Engine and other analysis modules.

Performance Note:
The `alerts` table is expected to grow large. For the queries in this router
to be performant, it is crucial to have a composite index on:
(project_id, status, severity, created_at DESC)
This was implemented in migration 008_indexes.sql.
"""

from datetime import datetime
from typing import List, Optional
from uuid import UUID
from fastapi import APIRouter, Depends, HTTPException, Query, status
from pydantic import BaseModel, Field

from src.core.database import get_session
from src.core.pagination import Page
from src.analysis.domain.enums import AlertStatus, AlertSeverity
from src.analysis.adapters.persistence.alert_repository import SqlAlchemyAlertRepository
from src.analysis.application.alerts_use_cases import (
    DeleteAlertUseCase,
    GetAlertUseCase,
    GetAlertsStatsUseCase,
    ListAlertsUseCase,
    UpdateAlertStatusUseCase,
)

# ===========================================
# PYDANTIC SCHEMAS
# ===========================================

class AlertBase(BaseModel):
    """Base alert schema."""
    category: Optional[str] = None
    severity: AlertSeverity
    title: str
    description: str
    recommendation: Optional[str] = None
    source_clause_id: Optional[UUID] = None
    affected_entities: dict = Field(default_factory=dict)
    alert_metadata: dict = Field(default_factory=dict)


class AlertRead(BaseModel):
    """Alert read schema."""
    id: UUID
    project_id: UUID
    analysis_id: Optional[UUID] = None
    severity: AlertSeverity
    category: Optional[str] = None
    rule_id: Optional[str] = None
    title: str
    description: str
    recommendation: Optional[str] = None
    source_clause_id: Optional[UUID] = None
    related_clause_ids: Optional[List[UUID]] = None
    affected_entities: dict
    impact_level: Optional[str] = None
    alert_metadata: dict
    status: AlertStatus
    approval_status: str
    resolved_at: Optional[datetime] = None
    resolved_by: Optional[UUID] = None
    resolution_notes: Optional[str] = None
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True


class AlertUpdate(BaseModel):
    """Alert update schema."""
    status: AlertStatus
    resolution_notes: Optional[str] = Field(
        None,
        description="Notes when resolving or dismissing an alert."
    )


class AlertsStats(BaseModel):
    """Statistics about alerts for a project."""
    total: int
    open: int
    resolved: int
    dismissed: int
    critical: int
    high: int
    medium: int
    low: int


# ===========================================
# ROUTER SETUP
# ===========================================

router = APIRouter(
    prefix="/alerts",
    tags=["Alerts"],
    responses={404: {"description": "Not found"}},
)

# ===========================================
# DEPENDENCY INJECTION
# ===========================================

def get_alert_repository(db=Depends(get_session)) -> SqlAlchemyAlertRepository:
    return SqlAlchemyAlertRepository(session=db)

def get_list_alerts_use_case(
    repo: SqlAlchemyAlertRepository = Depends(get_alert_repository),
) -> ListAlertsUseCase:
    return ListAlertsUseCase(repository=repo)

def get_alerts_stats_use_case(
    repo: SqlAlchemyAlertRepository = Depends(get_alert_repository),
) -> GetAlertsStatsUseCase:
    return GetAlertsStatsUseCase(repository=repo)

def get_get_alert_use_case(
    repo: SqlAlchemyAlertRepository = Depends(get_alert_repository),
) -> GetAlertUseCase:
    return GetAlertUseCase(repository=repo)

def get_update_alert_use_case(
    repo: SqlAlchemyAlertRepository = Depends(get_alert_repository),
) -> UpdateAlertStatusUseCase:
    return UpdateAlertStatusUseCase(repository=repo)

def get_delete_alert_use_case(
    repo: SqlAlchemyAlertRepository = Depends(get_alert_repository),
) -> DeleteAlertUseCase:
    return DeleteAlertUseCase(repository=repo)


# ===========================================
# ENDPOINTS
# ===========================================

@router.get(
    "/projects/{project_id}",
    response_model=Page[AlertRead],
    summary="List alerts for project",
    description="List alerts for a specific project with filtering and pagination."
)
async def list_alerts_for_project(
    project_id: UUID,
    severities: Optional[List[AlertSeverity]] = Query(None),
    statuses: Optional[List[AlertStatus]] = Query([AlertStatus.OPEN]),
    category: Optional[str] = Query(None),
    cursor: Optional[str] = None,
    limit: int = Query(20, ge=1, le=100),
    use_case: ListAlertsUseCase = Depends(get_list_alerts_use_case),
):
    """
    List alerts for a specific project with filtering and pagination.

    Args:
        project_id: The UUID of the project
        db: Database session
        severities: Optional list of severities to filter by
        statuses: Optional list of statuses to filter by (default: [OPEN])
        category: Optional category to filter by
        cursor: Pagination cursor
        limit: Number of items per page (1-100)

    Returns:
        Paginated list of alerts
    """
    return await use_case.execute(
        project_id=project_id,
        severities=severities,
        statuses=statuses,
        category=category,
        cursor=cursor,
        limit=limit,
    )


@router.get(
    "/projects/{project_id}/stats",
    response_model=AlertsStats,
    summary="Get alert statistics",
    description="Get statistics about alerts for a specific project."
)
async def get_alerts_stats(
    project_id: UUID,
    use_case: GetAlertsStatsUseCase = Depends(get_alerts_stats_use_case),
):
    """
    Get statistics about alerts for a specific project.

    Args:
        project_id: The UUID of the project
        db: Database session

    Returns:
        Alert statistics
    """
    stats = await use_case.execute(project_id)
    return AlertsStats(**stats)


@router.get(
    "/{alert_id}",
    response_model=AlertRead,
    summary="Get alert by ID",
    description="Get a single alert by its ID."
)
async def get_alert(
    alert_id: UUID,
    use_case: GetAlertUseCase = Depends(get_get_alert_use_case),
):
    """
    Get a single alert by its ID.

    Args:
        alert_id: The UUID of the alert
        db: Database session

    Returns:
        The alert

    Raises:
        HTTPException: 404 if alert not found
    """
    try:
        return await use_case.execute(alert_id)
    except ValueError:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Alert not found")


@router.patch(
    "/{alert_id}",
    response_model=AlertRead,
    summary="Update alert",
    description="Update an alert's status and add resolution notes."
)
async def update_alert(
    alert_id: UUID,
    alert_update: AlertUpdate,
    use_case: UpdateAlertStatusUseCase = Depends(get_update_alert_use_case),
    # TODO: Add current_user dependency when auth is integrated
):
    """
    Update an alert's status and add resolution notes.

    Args:
        alert_id: The UUID of the alert
        alert_update: The update data
        db: Database session

    Returns:
        The updated alert

    Raises:
        HTTPException: 404 if alert not found
        HTTPException: 400 if validation fails
    """
    try:
        return await use_case.execute(
            alert_id=alert_id,
            status=alert_update.status,
            resolution_notes=alert_update.resolution_notes,
        )
    except ValueError as exc:
        reason = str(exc)
        if reason == "alert_not_found":
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Alert not found")
        if reason.startswith("cannot_update_"):
            status_value = reason.replace("cannot_update_", "")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Cannot update an alert that is already {status_value}",
            )
        if reason == "invalid_status":
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Alert status can only be updated to RESOLVED, DISMISSED, or ACKNOWLEDGED",
            )
        raise


@router.delete(
    "/{alert_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete alert",
    description="Delete an alert (admin only)."
)
async def delete_alert(
    alert_id: UUID,
    use_case: DeleteAlertUseCase = Depends(get_delete_alert_use_case),
    # TODO: Add current_user dependency and check admin role
):
    """
    Delete an alert. This should only be used by administrators for cleanup.

    Args:
        alert_id: The UUID of the alert
        db: Database session

    Raises:
        HTTPException: 404 if alert not found
    """
    try:
        await use_case.execute(alert_id)
    except ValueError:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Alert not found")
