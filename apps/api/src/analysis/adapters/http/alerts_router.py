"""
C2Pro - Alerts API Router

This router exposes endpoints for managing and resolving alerts generated by
the Coherence Engine and other analysis modules.

Performance Note:
The `alerts` table is expected to grow large. For the queries in this router
to be performant, it is crucial to have a composite index on:
(project_id, status, severity, created_at DESC)
This was implemented in migration 008_indexes.sql.
"""

from typing import List, Optional
from uuid import UUID
from datetime import datetime

from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from pydantic import BaseModel, Field

from src.core.database import get_session
from src.core.pagination import Page, paginate
from src.analysis.adapters.persistence.models import (
    Alert,
    AlertStatus,
    AlertSeverity,
)

# ===========================================
# PYDANTIC SCHEMAS
# ===========================================

class AlertBase(BaseModel):
    """Base alert schema."""
    category: Optional[str] = None
    severity: AlertSeverity
    title: str
    description: str
    recommendation: Optional[str] = None
    source_clause_id: Optional[UUID] = None
    affected_entities: dict = Field(default_factory=dict)
    alert_metadata: dict = Field(default_factory=dict)


class AlertRead(BaseModel):
    """Alert read schema."""
    id: UUID
    project_id: UUID
    analysis_id: Optional[UUID] = None
    severity: AlertSeverity
    category: Optional[str] = None
    rule_id: Optional[str] = None
    title: str
    description: str
    recommendation: Optional[str] = None
    source_clause_id: Optional[UUID] = None
    related_clause_ids: Optional[List[UUID]] = None
    affected_entities: dict
    impact_level: Optional[str] = None
    alert_metadata: dict
    status: AlertStatus
    approval_status: str
    resolved_at: Optional[datetime] = None
    resolved_by: Optional[UUID] = None
    resolution_notes: Optional[str] = None
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True


class AlertUpdate(BaseModel):
    """Alert update schema."""
    status: AlertStatus
    resolution_notes: Optional[str] = Field(
        None,
        description="Notes when resolving or dismissing an alert."
    )


class AlertsStats(BaseModel):
    """Statistics about alerts for a project."""
    total: int
    open: int
    resolved: int
    dismissed: int
    critical: int
    high: int
    medium: int
    low: int


# ===========================================
# ROUTER SETUP
# ===========================================

router = APIRouter(
    prefix="/alerts",
    tags=["Alerts"],
    responses={404: {"description": "Not found"}},
)


# ===========================================
# ENDPOINTS
# ===========================================

@router.get(
    "/projects/{project_id}",
    response_model=Page[AlertRead],
    summary="List alerts for project",
    description="List alerts for a specific project with filtering and pagination."
)
async def list_alerts_for_project(
    project_id: UUID,
    db: AsyncSession = Depends(get_session),
    severities: Optional[List[AlertSeverity]] = Query(None),
    statuses: Optional[List[AlertStatus]] = Query([AlertStatus.OPEN]),
    category: Optional[str] = Query(None),
    cursor: Optional[str] = None,
    limit: int = Query(20, ge=1, le=100),
):
    """
    List alerts for a specific project with filtering and pagination.

    Args:
        project_id: The UUID of the project
        db: Database session
        severities: Optional list of severities to filter by
        statuses: Optional list of statuses to filter by (default: [OPEN])
        category: Optional category to filter by
        cursor: Pagination cursor
        limit: Number of items per page (1-100)

    Returns:
        Paginated list of alerts
    """
    # Build query
    query = select(Alert).where(Alert.project_id == project_id)

    # Apply filters
    if severities:
        query = query.where(Alert.severity.in_(severities))
    if statuses:
        query = query.where(Alert.status.in_(statuses))
    if category:
        query = query.where(Alert.category == category)

    # Order by severity (critical first) and then by creation date
    query = query.order_by(Alert.severity.desc(), Alert.created_at.desc())

    # Paginate
    return await paginate(
        query=query,
        model=Alert,
        cursor=cursor,
        limit=limit,
        order_by="created_at",
        order_direction="desc"
    )


@router.get(
    "/projects/{project_id}/stats",
    response_model=AlertsStats,
    summary="Get alert statistics",
    description="Get statistics about alerts for a specific project."
)
async def get_alerts_stats(
    project_id: UUID,
    db: AsyncSession = Depends(get_session),
):
    """
    Get statistics about alerts for a specific project.

    Args:
        project_id: The UUID of the project
        db: Database session

    Returns:
        Alert statistics
    """
    # Fetch all alerts for the project
    result = await db.execute(
        select(Alert).where(Alert.project_id == project_id)
    )
    alerts = result.scalars().all()

    # Calculate statistics
    stats = {
        "total": len(alerts),
        "open": sum(1 for a in alerts if a.status == AlertStatus.OPEN),
        "resolved": sum(1 for a in alerts if a.status == AlertStatus.RESOLVED),
        "dismissed": sum(1 for a in alerts if a.status == AlertStatus.DISMISSED),
        "critical": sum(1 for a in alerts if a.severity == AlertSeverity.CRITICAL),
        "high": sum(1 for a in alerts if a.severity == AlertSeverity.HIGH),
        "medium": sum(1 for a in alerts if a.severity == AlertSeverity.MEDIUM),
        "low": sum(1 for a in alerts if a.severity == AlertSeverity.LOW),
    }

    return AlertsStats(**stats)


@router.get(
    "/{alert_id}",
    response_model=AlertRead,
    summary="Get alert by ID",
    description="Get a single alert by its ID."
)
async def get_alert(
    alert_id: UUID,
    db: AsyncSession = Depends(get_session),
):
    """
    Get a single alert by its ID.

    Args:
        alert_id: The UUID of the alert
        db: Database session

    Returns:
        The alert

    Raises:
        HTTPException: 404 if alert not found
    """
    result = await db.execute(
        select(Alert).where(Alert.id == alert_id)
    )
    alert = result.scalar_one_or_none()

    if not alert:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Alert not found"
        )

    return alert


@router.patch(
    "/{alert_id}",
    response_model=AlertRead,
    summary="Update alert",
    description="Update an alert's status and add resolution notes."
)
async def update_alert(
    alert_id: UUID,
    alert_update: AlertUpdate,
    db: AsyncSession = Depends(get_session),
    # TODO: Add current_user dependency when auth is integrated
):
    """
    Update an alert's status and add resolution notes.

    Args:
        alert_id: The UUID of the alert
        alert_update: The update data
        db: Database session

    Returns:
        The updated alert

    Raises:
        HTTPException: 404 if alert not found
        HTTPException: 400 if validation fails
    """
    # Fetch alert
    result = await db.execute(
        select(Alert).where(Alert.id == alert_id)
    )
    alert = result.scalar_one_or_none()

    if not alert:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Alert not found"
        )

    # Validate status transitions
    if alert.status != AlertStatus.OPEN:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Cannot update an alert that is already {alert.status.value}"
        )

    if alert_update.status not in [AlertStatus.RESOLVED, AlertStatus.DISMISSED, AlertStatus.ACKNOWLEDGED]:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Alert status can only be updated to RESOLVED, DISMISSED, or ACKNOWLEDGED"
        )

    # Update status
    alert.status = alert_update.status

    # If resolving or dismissing, set resolution fields
    if alert_update.status in [AlertStatus.RESOLVED, AlertStatus.DISMISSED]:
        alert.resolved_at = datetime.utcnow()
        if alert_update.resolution_notes:
            alert.resolution_notes = alert_update.resolution_notes
        # TODO: Set resolved_by when auth is integrated
        # alert.resolved_by = current_user.id

    # Commit changes
    await db.commit()
    await db.refresh(alert)

    return alert


@router.delete(
    "/{alert_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete alert",
    description="Delete an alert (admin only)."
)
async def delete_alert(
    alert_id: UUID,
    db: AsyncSession = Depends(get_session),
    # TODO: Add current_user dependency and check admin role
):
    """
    Delete an alert. This should only be used by administrators for cleanup.

    Args:
        alert_id: The UUID of the alert
        db: Database session

    Raises:
        HTTPException: 404 if alert not found
    """
    result = await db.execute(
        select(Alert).where(Alert.id == alert_id)
    )
    alert = result.scalar_one_or_none()

    if not alert:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Alert not found"
        )

    await db.delete(alert)
    await db.commit()
