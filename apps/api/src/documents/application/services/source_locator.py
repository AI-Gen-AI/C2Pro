"""
C2Pro - Source Locator Service

This service is responsible for linking AI-generated text evidence back to its
exact source within a document, using a combination of direct lookups and
fuzzy text matching.
"""

import re
import sys
import subprocess
from typing import List, Optional
from uuid import UUID

import structlog
from pydantic import BaseModel, Field

from src.documents.ports.document_repository import IDocumentRepository

# --- Dependency Check ---
try:
    from rapidfuzz import fuzz, process
except ImportError:
    print("rapidfuzz library not found. Attempting to install...")
    try:
        subprocess.check_call([sys.executable, "-m", "pip", "install", "rapidfuzz"])
        from rapidfuzz import fuzz, process
        print("rapidfuzz installed successfully.")
    except Exception as e:
        print(f"Failed to install rapidfuzz: {e}. Please install it manually: pip install rapidfuzz")
        sys.exit(1)


logger = structlog.get_logger()


# Pydantic model for the enriched evidence location
class SourceLocation(BaseModel):
    """
    Represents the precise location of a piece of evidence within a document.
    """
    document_id: UUID = Field(..., description="The ID of the document containing the evidence.")
    page_number: int | None = Field(None, description="The page number where the evidence is found.")
    chunk_text: str = Field(..., description="The actual text of the matched chunk from the document.")
    similarity_score: int = Field(..., description="The confidence score of the match (0-100).")
    bbox: Optional[List[float]] = Field(None, description="Bounding box for highlighting in a PDF viewer.")


class SourceLocator:
    """
    Finds the source of AI-generated text within project documents.
    """
    def __init__(self, document_repository: IDocumentRepository):
        self.document_repository = document_repository
        # Regex to find clause references like "Clause 14.2" or "Sub-Clause 3.1.a"
        self.clause_regex = re.compile(r'(?:cláusula|clause|sub-clause|sub-cláusula)\s+([0-9]+\.[0-9]+(?:\.[a-zA-Z0-9]+)*)', re.IGNORECASE)

    async def locate_evidence(
        self,
        query_text: str,
        document_id: UUID,
        min_similarity_score: int = 85
    ) -> SourceLocation | None:
        """
        Locates the best source for a given query text within a document.

        It uses a hybrid approach:
        1.  **Fast Path**: Attempts to extract a clause code from the query and find an exact match.
        2.  **Slow Path**: If the fast path fails, it performs a fuzzy search over all clauses
            in the document to find the best partial match.

        Args:
            query_text: The text generated by the LLM (the "evidence quote").
            document_id: The ID of the document to search within.
            min_similarity_score: The minimum score (0-100) for a fuzzy match to be considered valid.

        Returns:
            A SourceLocation object if a satisfactory match is found, otherwise None.
        """
        # --- Fast Path: Direct Code Match ---
        match = self.clause_regex.search(query_text)
        if match:
            clause_code = match.group(1)
            clause = await self.document_repository.get_clause_by_document_and_code(
                document_id=document_id,
                clause_code=clause_code,
            )
            if clause:
                logger.info("source_locator_fast_path_success", clause_code=clause_code)
                return SourceLocation(
                    document_id=document_id,
                    page_number=None, # Page number is not stored on Clause model
                    chunk_text=clause.full_text or "",
                    similarity_score=100,
                    bbox=None, # Bbox is not stored on Clause model
                )

        # --- Slow Path: Fuzzy Search ---
        logger.info("source_locator_slow_path_started", document_id=document_id)
        all_clauses = await self.document_repository.list_clauses_for_document(document_id=document_id)

        if not all_clauses:
            logger.warning("source_locator_no_clauses", document_id=document_id)
            return None

        # Create a dictionary of clause texts to search against
        choices = {c.id: c.full_text for c in all_clauses if c.full_text}
        
        # Use rapidfuzz to find the best match
        best_match = process.extractOne(query_text, choices, scorer=fuzz.partial_ratio)

        if best_match and best_match[1] >= min_similarity_score:
            match_score, match_key = best_match[1], best_match[2]
            matched_clause = next((c for c in all_clauses if c.id == match_key), None)
            
            if matched_clause:
                logger.info("source_locator_slow_path_success", best_score=match_score)
                return SourceLocation(
                    document_id=document_id,
                    page_number=None, # Page number is not on Clause model
                    chunk_text=matched_clause.full_text or "",
                    similarity_score=int(match_score),
                    bbox=None, # Bbox is not on Clause model
                )

        logger.warning("source_locator_no_match_found", min_score=min_similarity_score)
        return None
